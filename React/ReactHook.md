## class组件存在哪些问题？
* 大型组件很难产分和重构，很难测试
* 相同的业务逻辑，分散到各个生命周期中，逻辑混乱
* 复用逻辑变得复杂。
## Hooks使用规范
1. 只能用于React函数组件和自定义hook中
2. 只能在组建的顶层调用，不能在循环和条件语句（如 if）中调用，除了use

## 组件的记忆
命名公约: React 组件名称必须以大写字母开头

1. 局部变量无法在多次渲染中持久保存。 当 React 再次渲染这个组件时，它会从头开始渲染——不会考虑之前对局部变量的任何更改。
2. 更改局部变量不会触发渲染。 React 没有意识到它需要使用新数据再次渲染组件。

要使用新数据更新组件，需要做两件事：

1. 保留 渲染之间的数据。
2. 触发 React 使用新数据渲染组件（重新渲染）

useState Hook 提供了这两个功能：

1. State 变量 用于保存渲染间的数据。
2. State setter 函数 更新变量并触发 React 再次渲染组件。

## 渲染和提交
请求和提供 UI 的过程总共包括三个步骤：

1. 触发 一次渲染（把客人的点单分发到厨房）
2. 渲染 组件（在厨房准备订单）
3. 提交 到 DOM（将菜品放在桌子上）

### 步骤 1: 触发一次渲染 

有两种原因会导致组件的渲染:

1. 组件的 初次渲染--当应用启动时，会触发初次渲染。
2. 组件（或者其祖先之一）的 状态发生了改变。

当 React 重新渲染一个组件时：

1. React 会再次调用你的函数
2. 函数会返回根据当前渲染时的 state 计算出来的 JSX 快照，变量和事件处理函数不会在重渲染中“存活”。每个渲染都有自己的事件处理函数。
3. React 会更新界面以匹配返回的快照


### 步骤 2: React 渲染你的组件 
* 在进行初次渲染时, React 会调用根组件, 创建 DOM 节点。
* 对于后续的渲染, React 会调用内部状态更新触发了渲染的函数组件, React 将计算它们的哪些属性（如果有的话）自上次渲染以来已更改。在下一步（提交阶段）之前，它不会对这些信息执行任何操作。

### 步骤 3: React 把更改提交到 DOM 上

在渲染（调用）你的组件之后，React 将会修改 DOM。

* 对于初次渲染， React 会使用 appendChild() DOM API 将其创建的所有 DOM 节点放在屏幕上。
* 对于重渲染， React 将应用最少的必要操作（在渲染时计算！），以使得 DOM 与最新的渲染输出相互匹配。
## Hooks状态管理
构建 state 的原则：
1. 合并关联的 state。如果你总是同时更新两个或更多的 state 变量，请考虑将它们合并为一个单独的 state 变量。
2. 避免互相矛盾的 state。当 state 结构中存在多个相互矛盾或“不一致”的 state 时，你就可能为此会留下隐患。应尽量避免这种情况。
3. 避免冗余的 state。如果你能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入该组件的 state 中。
4. 避免重复的 state。当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少重复。
5. 避免深度嵌套的 state。深度分层的 state 更新起来不是很方便。如果可能的话，最好以扁平化方式构建 state。

状态提升:

两个组件的状态始终同步更改。要实现这一点，可以将相关 state 从这两个组件上移除，并把 state 放到它们的公共父级，再通过 props 将 state 传递给这两个组件。这是编写 React 代码时常做的事。

每当你尝试保持两个不同的 state 变量之间的同步时，试试状态提升


重置 state:

1. 方法一：将组件渲染在不同的位置
2. 方法二：使用 key 来重置 state

## Hooks
在 React 中，useState 以及任何其他以“use”开头的函数都被称为 Hook.

只能在组件的最顶层调用hook,不应在循环或者条件语句中调用,除了 use hook.

### useState
useState Hook 返回一对值：当前 state 和更新它的函数，惯例是将这对返回值命名为 const [thing, setThing]

State 是隔离且私有的,完全私有于声明它的组件--如果你渲染同一个组件两次，每个副本都会有完全隔离的 state！

如果一个值可以基于现有的 props 或 state 计算得出，不要把它作为一个 state，而是在渲染期间直接计算这个值

### useEffect
Effect 在 React 中是专有定义——由渲染引起的副作用。编写 Effect 需要遵循以下三个规则：

1. 声明 Effect。默认情况下，Effect 会在每次渲染后都会执行。
2. 指定 Effect 依赖。大多数 Effect 应该按需执行，而不是在每次渲染后都执行。例如，淡入动画应该只在组件出现时触发。连接和断开服务器的操作只应在组件出现和消失时，或者切换聊天室时执行。文章将介绍如何通过指定依赖来控制如何按需执行。
3. 必要时添加清理（cleanup）函数。有时 Effect 需要指定如何停止、撤销，或者清除它的效果。例如，“连接”操作需要“断连”，“订阅”需要“退订”，“获取”既需要“取消”也需要“忽略”。清理函数执行时机：每次重新执行 Effect 之前，React 都会调用清理函数；组件被卸载时，也会调用清理函数。


useEffect是开发过程中最长用的hooks之一,在开发自己暗示，非常容易出现过度使用或者滥用。阅读下面这边文章有助于减少不必要的Effect逻辑。[《你可能不需要Effect》](https://react.docschina.org/learn/you-might-not-need-an-effect#sharing-logic-between-event-handlers)

如何移除不必要的 Effect。
1. 如果你可以在渲染期间计算某些内容，则不需要使用 Effect。
2. 想要缓存昂贵的计算，请使用 useMemo 而不是 useEffect。
3. 想要重置整个组件树的 state，请传入不同的 key。
4. 想要在 prop 变化时重置某些特定的 state，请在渲染期间处理。
5. 组件 显示 时就需要执行的代码应该放在 Effect 中，否则应该放在事件处理函数中。
6. 如果你需要更新多个组件的 state，最好在单个事件处理函数中处理。
7. 当你尝试在不同组件中同步 state 变量时，请考虑状态提升。
8. 你可以使用 Effect 获取数据，但你需要实现清除逻辑以避免竞态条件。

避免情况：
* 避免：当 prop 变化时，在 Effect 中重置 state
* 避免：当 prop 变化时，在 Effect 中调整 state
* 避免：在 Effect 中处理属于事件特定的逻辑
* 避免：链接多个 Effect 仅仅为了相互触发调整 state
* 避免：把每次应用只需要加载时执行一次的逻辑放在 Effect 中，如用户token验证等（注意：这里说的是每次应用只需要加载时执行一次的逻辑，而不是每次组件挂载时执行一次的逻辑，两者是有区别的）
* 避免：onChange 处理函数执行的时间太晚了
* 避免：在 Effect 中传递数据给父组件
* 避免：没有清除逻辑的获取数据

响应式 Effect 的生命周期

Effect 与组件有不同的生命周期。组件可以挂载、更新或卸载。Effect 只能做两件事：开始同步某些东西，然后停止同步它。

代码中的每个 Effect 应该代表一个独立的同步过程。

删除一个 Effect 不会影响另一个 Effect 的逻辑。这表明它们同步不同的内容，因此将它们拆分开是有意义的。另一方面，如果将一个内聚的逻辑拆分成多个独立的 Effects，代码可能会看起来更加“清晰”，但 维护起来会更加困难。这就是为什么你应该考虑这些过程是相同还是独立的，而不是只考虑代码是否看起来更整洁。

直观上，你可以说事件处理函数总是“手动”触发的，例如点击按钮。另一方面， Effect 是自动触发：每当需要保持同步的时候他们就会开始运行和重新运行。



```js
useEffect(() => {
  // 这里的代码会在每次渲染后执行
});

useEffect(() => {
  // 这里的代码只会在组件挂载后执行
}, []);

useEffect(() => {
  // 这里的代码只会在每次渲染后，并且 a 或 b 的值与上次渲染不一致时执行
}, [a, b]);
```
React 使用 Object.is 比较依赖项的值。

仅开发环境下的行为 
在 严格模式 下，React 在每次挂载组件后都会重新挂载组件（但是组件的 state 与 创建的 DOM 都会被保留）。它可以帮助你找出需要添加清理函数的 Effect，以及早暴露出像条件竞争那样的问题。此外，每当你在开发环境中保存更新代码文件时，React 也会重新挂载 Effect，不过这两种行为都仅限于开发环境。
 

### useRef
Refs 是一种脱围机制。当你希望组件“记住”某些信息，但又不想让这些信息 触发新的渲染 时，你可以使用 ref。以下是这些罕见情况中的几个：

* 存储 timeout ID
* 存储和操作 DOM 元素，我们将
在 下一页 中介绍
* 存储不需要被用来计算 JSX 的其他对象。

### useId
useId 是一个 React Hook，可以生成传递给无障碍属性的唯一 ID。用法

* 为无障碍属性生成唯一 ID
* 为多个相关元素生成 ID
* 为所有生成的 ID 指定共享前缀
* 在客户端和服务端上使用相同的 ID 前缀

不要使用 useId 来生成列表中的 key。key 应该由你的数据生成。


### useReducer
### useCallback
是一个允许你在多次渲染中缓存函数的 React Hook

用法
* 跳过组件的重新渲染
* 从记忆化回调中更新 state
* 防止频繁触发 Effect
* 优化自定义 Hook

### useMemo
### useLayoutEffect
### useDebugValue

### 自定义hook
自定义 Hook 共享的是状态逻辑，而不是状态本身--对 Hook 的每个调用完全独立于对同一个 Hook 的其他调用

命名公约：Hook 的名称必须以 use 开头，然后紧跟一个大写字母.

## 重要问题
1. 为什么 state 不在设置后立即更新

更新多个 state 变量——甚至来自多个组件的 state 变量——而不会触发太多的 重新渲染。但这也意味着只有在你的事件处理函数及其中任何代码执行完成 之后，UI 才会更新。这种特性也就是 批处理，它会使你的 React 应用运行得更快。它还会帮你避免处理只​​更新了一部分 state 变量的令人困惑的“半成品”渲染。